# **Dict**

**Словари** - это неупорядоченная структура данных, в которой у\
каждого элемента есть своя ассоциация (ключ). Данные представляются\
в виде элементов ключ:значение.

Ключи могут быть **ТОЛЬКО** неизменяемыми типами данных, значения могут\
быть любыми типами данных.

```python
# new_dict = {} # создаст пустой словарь.
my_list = [1, 2, 3, 4, 5, 6]
students = {
    "name": "Vlad",
    "surname": "Lebovski",
    "age": 25,
    "sex": "male",
    "education": "engineer",
    5: "test"
}
```

Мы можем обращаться к ключам наших словарей, получая по ним значения:

```python
students["name"]
```

Если мы попытаемся таким образом обратиться к ключу, которого нет - получим\
**KeyError**:

```python
# student["work"]
```
Для этого у нас есть метод `.get()`

**Мы так же можем создавать новые ключи и давать им значения:**

```python
student["work"] = "Amazon company" # создаст новый ключ work и даст ему значение Amazon company
```

```python
del student[5] # удалит наш ключ 5 и его значение
```

**Как ещё можно создавать словари?**

```python
dict_1 = dict(name="Vlad",
              age=32,
              sex="binary person",
              job="driver",
              asd="asdasd")

print(dict_1)
```
```python
dict_2 = dict([("pet", "dog"), ("name", "fluffy"), ("age", 3), ("hungry", False)])

print(dict_2)
```

```python
keys_list = ("name", "age", "job")
values_list = ["David", 45, "QA"]

dict_3 = dict(zip(keys_list, values_list))
```

```python
# задача с собеседования
my_new_dict = {
    1: "father",
    False: "mother",
    True: "son",
}
```

**Вложенные словари:**

Мы так же можем создавать **вложенные словари** для создания более\
сложных структур. Частенько можно встретить в **JSON** данных,\
которые **backend** подготавливает для **frontend**.

```python
employee = {
    "id": 1,
    "name": "Valeria",
    "surname": "Black",
    "age": 21,
    "education": "hight",
    "current work": {
        "id": 1,
        "position": "QA engineer",
        "work experience": "3 years",
        "work qualification": "QA"
    }
}
```

```python
employee_1 = {
    "id": 1,
    "name": "Valeria",
    "surname": "Black",
    "age": 21,
    "education": "hight",
    "work_experience": [
        {
            "id": 1,
            "position": "QA engineer",
            "work experience": "5 years",
            "work qualification": "junior"
        },
        {
            "id": 2,
            "position": "software developer",
            "work experience": "1.3 years",
            "work qualification": "middle"
        },
        {
            "id": 3,
            "position": "QA engineer",
            "work experience": "1 years",
            "work qualification": "senior"
        }
    ],
}
```

---

# **Dict methods**

* `keys()`: Метод **keys()** возвращает представление всех ключей в словаре.

```python
employee.keys()
```

* `values()` возвращает представление всех значений в словаре.

```python
employee.values()
```

* `items()` возвращает представление всех пар "ключ-значение" в\
словаре в виде кортежей.

```python
employee.items()
```

* `get()`: позволяет получить значение по ключу с возможностью\
указать значение по умолчанию, если ключ не существует.

```python
employee.get("rabota", "NOT FOUND")
```

* `setdefault()`: позволяет получить значение по ключу, а если ключ\
не существует, то установить значение по умолчанию и вернуть его.

```python
employee.setdefault("pet", True)
```

* `fromkeys(iterable, value=None)`: создает новый словарь, используя\
элементы из итерируемого объекта (например, список) как ключи, и\
устанавливает для каждого ключа значение по умолчанию (по\
умолчанию None, но вы можете указать своё значение).

```python
keys = ['a', 'b', 'c']
default_value = 0
new_dict = dict.fromkeys(keys, default_value)

print(new_dict)  # Вывод: {'a': 0, 'b': 0, 'c': 0}
```

* `pop(key, default)`: удаляет элемент из словаря по указанному\
ключу и возвращает его значение. Если ключ не найден, метод вернет\
значение, указанное в `default` (по умолчанию вызовет исключение\
`KeyError`).\

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
value = my_dict.pop('b')  # Удаляем ключ 'b' и получаем его значение

print(my_dict)  # Вывод: {'a': 1, 'c': 3}
print(value)    # Вывод: 2
```

* `popitem()`: удаляет и возвращает произвольный элемент (ключ-значение)\
из словаря. Этот метод может быть полезен, если вам не важно,\
какой именно элемент будет удален.

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
item = my_dict.popitem()  # Удаляем произвольный элемент

print(my_dict)  # Вывод: {'a': 1, 'b': 2}
print(item)     # Вывод: ('c', 3)
```

* `copy()`: создает и возвращает копию словаря. Эта копия будет\
независимой от исходного словаря, что означает, что изменения в\
копии не будут влиять на исходный словарь, и наоборот.

```python
original_dict = {'a': 1, 'b': 2, 'c': 3}
copied_dict = original_dict.copy()

copied_dict['a'] = 99  # Изменение копии не влияет на исходный словарь
print(original_dict)    # Вывод: {'a': 1, 'b': 2, 'c': 3}
print(copied_dict)      # Вывод: {'a': 99, 'b': 2, 'c': 3}
```

Обязательно помните, что если вам нужна копия вашего словаря, с какой-то\
вложенностью, и вы собираетесь как-то эту копию изменять - обычный метот\
`copy()` не сработает, так как для всех изменяемых объектов он оставляет\
прежние ссылки, тем самым при изменении вложенных структур в вашей копии\
вы будите изменять и вложенные структуры оригинала.

```python
a = {
    "b": [2, 4, 6, 8, 10],
    "c": 700,
    "d": {
        "a": 85
    }
}

f = a.copy()

f["b"][0] = 100
f["d"]["a"] = "700"

print(f)
print(a)
```

Чтобы такого поведения не происходило, подключайте в работу специальный\
метод `deepcopy()` из библиатеки `copy`

`deepcopy` - это функция из модуля copy в **Python**, которая используется для\
создания глубокой копии объекта. Глубокая копия означает, что все объекты\
внутри исходного объекта также копируются рекурсивно, то есть создаются\
копии всех вложенных объектов. Это полезно, когда вам нужно создать\
независимую копию сложной структуры данных, такой как вложенный словарь\
или список, чтобы изменения в одной копии не влияли на другую.


```python
import copy

a = {
    "b": [2, 4, 6, 8, 10],
    "c": 700,
    "d": {
        "a": 85
    }
}

f = copy.deepcopy(a)

f["b"][0] = 100
f["d"]["a"] = "700"

print(f)
print(a)
```

---

# **Conclusion:**

# **Common points for dict and set:**

* **Общие черты словарей и множеств:**
    * **Оба являются коллекциями в Python.**
    * **Позволяют хранить и организовывать данные.**
* **Основные различия между словарями и множествами:**
    * Словари хранят пары "ключ-значение", в то время как множества\
    хранят только уникальные элементы без порядка.
    * Доступ к значениям в словаре осуществляется по ключу, в\
    множестве - по самому элементу.
    * Словари могут содержать разные типы данных в качестве ключей и\
    значений, в то время как множества могут содержать только хешируемые\
    объекты(неизменяемые типы данных).
    * Множества поддерживают операции над множествами, такие как объединение,\
    пересечение и разность, в то время как словари таких операций не поддерживают


# **When dicts? When sets?**

* **Словари:**
    * Необходимо хранить и получать значения по уникальным ключам.
    * Нужно отображение между ключами и значениями.
    * Требуется изменяемость значений

* **Множества:**
    * Необходимо хранить только уникальные элементы без порядка.
    * Требуется выполнение операций над множествами, таких как объединение,\
    пересечение или разность.
    * Нужно проверить принадлежность элемента к множеству.


---

# **Tasks**

1) Создайте словарь **student_grades**, где ключами будут имена студентов,\
а значениями - их оценки (целые числа). Запросите у пользователя имя\
студента и выведите его оценку. Если студент не найден в словаре,\
выведите "Студент не найден".

2) Создайте словарь **inventory** с товарами и их количеством в магазине.\
Попросите пользователя ввести название товара и проверьте, есть ли этот\
товар в словаре. Если товар не найден, установите для этого товара значение\
4 по умолчанию.

3) Создайте два словаря **english_words** и **spanish_words** с переводами английских\
и испанских слов. Попросите пользователя ввести слово на английском и\
выведите его перевод на испанский. Если слово не найдено, выведите\
"Перевод не найден".

```python
spanish_words = {
    "Бабочка": "Mariposa",
    "Обучение": "Formación",
    "Ресторан": "Restaurante",
    "Программирование": "Programación",
}

english_words = {
    "Butterfly": "Бабочка",
    "Training": "Обучение",
    "Restaurant": "Ресторан",
    "Programming": "Программирование",
}
```

4) Создайте словарь **phone_book** с именами контактов и их номерами телефонов.\
Попросите пользователя ввести имя контакта и выведите его номер.\
Если контакт не найден, спросите пользователя, хочет ли он создать новый контакт.\
Если да - создайте новый ключ с номером телефона, который пользователь должен\
будет ввести. Если нет - прекратить работу.

```python
book_contact = {
    "Andrey": "+1234568789",
    "Irina": "+793545613254",
    "Nikita": "+995557003215",
    "Alex": "789456123121",
}
```

# **Loops**

**Циклы** - это важная часть программирования, которая позволяет выполнять\
один и тот же блок кода несколько раз. Они особенно полезны, когда вам\
нужно обработать данные, повторить определенное действие или выполнить\
итерацию через элементы в структурах данных.

**Какой синтаксис написания циклов:**

```python
for <local_variable> in <iterable_object>:
    <some code>
```

```python
for i in range(1, 11):
    print(f" Hello, World!!! - - - - - {i}")
```

**Немного общих понятий:**

* **Цикл** - это процесс повторения какого-либо действия или обход\
по какому-нибудь итерированному объекту.

* **Итерируемый объект** – это объект, у которого можно брать элементы\
по одному (строки, списки, кортежи, множества, словари и др).

* **Итерация** - это шаг или организация обработки данных, таким образом,\
когда действие происходит многократно.


**Области применения наших циклов:**

1) **Обработка итерируемых объектов**: Циклы позволяют проходить по элементам\
итерируемых объектов, таких как **списки**, **кортежи**, **строки** и **словари**,\
и выполнять некоторые действия для каждого элемента.

```python
string = "qwerty"

# для буквы в строке:
for letter in string:
  print(f"The iteration number: {string.index(letter) + 1}, the 'letter' value: {letter}")
```

2) **Выполнение блока кода заданное количество раз**: Циклы могут быть\
использованы для выполнения определенного блока кода заданное количество\
раз. Например, когда нам нужно повторить операцию 10 раз или пока не\
будет выполнено определенное условие.


```python
# построить треугольник
spec_symbol = "*"

for i in range(1, 6):
  print(spec_symbol * i)
```

```python
some_value = 5

for i in range(1, 6):
  print(some_value ** i)
```

3) **Обработка данных:** Циклы позволяют нам обрабатывать данные,\
вводимые пользователем, из файла или полученные из другого источника.

---

**Разновидности циклов и их отличия**

**В целом у нас таки два вида циклов:**

* `for`:
    * Срабатывающий определенное количество раз
    * Есть параметр(ы)
    * Известно количество итераций
* `while`:
    * работает по какому-то условию (пока оно True)
    * неизвестное количество итераций (пока условие верно цикл будет выполняться)

---

# **FOR**

Наш цикл **for** работает с итерируемыми объектами.


**Разберём его чуть детальнее:**

```python
for <local_variable> in <iterable_object>:
  <your code block with\without local variable>
```

* `for` - определение того, что сейчас будет цикл
* `local_variable` - локальная переменная, которая создаётся для\
хранения значения из объекта на каждой итерации. Каждую след\
итерацию в этой переменной храниться обновлённое значение.
* `in` - говорит нашему циклу, по какому объекту мы будем проходиться\
этим самым циклом (в рамках какого объекта будет работать цикл)
* `<iterable_object>` - объект, по которому мы будем проходиться\
и что-то с ним делать.
* `<your code block>` - блок кода, в котором будут происходить\
какие-то манипуляции со значениями из объекта


Наша локальная переменная `local_variable` в рамках нашего цикла может\
обзываться как угодно. Общепринято называть эту переменную логически\
подвязаной к нашему итерируемому объекту


**Давайте попробуем что-нибудь написать:**

нужно ввести числа через запятую, дальше все чётные числа нужно возвести\
в квадрат, все нечётные - вычесть корень


Есть некие уникальные айдишники, записанные в множестве.\
Нужно сконвертировать все эти айдишники в строки. Исходные данные\
НЕ должны быть изменены.


Есть строка                                       
```python
some_string = "njk23@&#^masndi0u132wa}dda<nuj*>?gb?gasd?"
```
Необходимо отделить числа, символы, буквы. Всё отдельно в разные\
строки.

---

Обход циклом по таким коллекциям, как **списки**, **строки**,\
**кортежи** и **множества** очень похож друг на друга. А вот со\
**словарями** уже всё более интересно.
Там мы можем пройтись циклом просто по словарю. В таком случае по дефолту\
мы будем проходиться по **ключам** нашего словаря:


```python
my_dict = {
    "a": 1,
    "b": 2,
    "c": 3
}

for elem in my_dict:
  print(elem)

# for key, value in my_dict: получите в лицо ошибку, связанную с                                  
# распоковкой ваших значений из словаря print(key, value)
```


Так же мы можем проходиться только по **ключам**:

```python
my_dict = {
    "a": 1,
    "b": 2,
    "c": 3
}

for key in my_dict.keys():
  print(key)
```


Только по **значениям** ключей:

```python
my_dict = {
    "a": 1,
    "b": 2,
    "c": 3
}

for value in my_dict.values():
  print(value)
```

И по цельным **парам** - ключ: значение:

```python
my_dict = {
    "a": 1,
    "b": 2,
    "c": 3
}
#w [('a', 1), ('b', 2), ('c', 3)]
for key, value in my_dict.items():
  print(key, value)
```

Так же бывают моменты, когда нам не нужно проходиться циклом по\
какому-то объекту, а просто сделать какое-то действие несколько раз\
подряд. В таком случае мы можем передавать в цикл просто объект **range()**:

```python
for _ in range(1, 11):
  print("Some really needed info")
```

Мы можем так же сделать своего рода имитацию загрузки:

```python
# имитация загрузки

import time
import sys

total = 50
delay = 0.2

for i in range(total + 1):
  percent = i * 100 / total
  progress = "#" * i
  sys.stdout.write(f"Loading process: [{progress}] {percent:.1f}%")
  sys.stdout.flush()
  time.sleep(delay)
  sys.stdout.write("\r")
```

В циклах так же есть специальный инструмент, позволяющий останавливать\
весь цикл, и инструмент, позволяющий пропускать текущую итерацию.\
Давайте посмотрим на них:

* **break** - полностью останавливает весь цикл. Удобен в использовании,\
когда при выполнении конкретного условия нужно полностью остановить\
выполнение цикла.

* **continue** - позволяет пропустить текущую итерацию и перейти сразу к\
следующей.


# **Tasks**

---
1. Напишите программу, которая запрашивает у пользователя список чисел и\
затем запрашивает число для поиска. Используйте цикл для поиска числа в\
списке. Если число найдено, прервите цикл с помощью **break**, иначе\
выведите сообщение о том, что число не найдено.

2. Вывод нечетных чисел: Напишите программу, которая выводит все числа\
от 1 до 10, кроме четных. Используйте цикл для перебора чисел и\
оператор **continue**, чтобы пропустить четные числа и продолжить\
вывод только нечетных.

3. Поиск уникальных элементов:
Создайте список, содержащий несколько элементов. Используйте цикл для\
создания нового списка, который будет содержать только уникальные\
элементы из исходного списка (без повторений).

4. Работа с исключениями:
Напишите небольшую "игру" на угадывание числа. Пользователь должен\
ввести 1) колличество попыток 2) диапазон загадывания числа для робота.\
Нужно угадать число, которое загадает робот. Если всё ок - вывести\
сообщение с победой и остановить цикл. Если нет - вывести соответствующее\
сообщение. Обработать возможные ошибки.
---

# **Nested loops**

вы можете вкладывать один цикл внутри другого. Это называется вложенными\
циклами. Это может быть полезно для обработки двумерных структур данных\
или выполнения сложных многократных операций.


Давайте посмотрим как они могут работать. Здесь шо, собсна, происходит:\
у нас есть список со списками, мы влетаем в главный список первым циклом\
берём первый элемент (а это список), и входим в него вторым, вложенным\
циклом. Как только мы пройдём все элементы этого внутреннего списка,\
закончился только **ПЕРВАЯ ИТЕРАЦИЯ** внешнего цикла.
```python
some_values = [
  [1, 2, 3],
  [3, 4, 5],
  [5, 6, 7],
  [7, 8, 9],
  [9, 10, 11]
]
new_list = []

for value in some_values:
  for num in value:
    new_list.append(num ** 2)

print(new_list)
```

Напишем небольшой код на поиск элемента в матрице. Ввести координаты,\
по которым находится элемент.

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

Можем даже нарисовать шахматную доску:

```python
size = 6  # Размер доски (6х6)

for row in range(size):
    for col in range(size):
        if (row + col) % 2 == 0:
            print("⬛️", end="")  # Черные клетки
        else:
            print("⬜️", end="")  # Белые клетки
    print()  # Переход на новую строку
```

**Работа циклов с вложенными элементами**

вы можете итерировать по элементам словаря и работать с его\
ключами и значениями с помощью цикла `for`. Вложенные словари могут\
быть использованы для представления сложных структур данных.


Есть список фильмов:
```python
films = {
    "Парасайт": {
        "рейтинг": 8.6,
        "описание": "Триллер о семье, внедрившейся в дом богатой семьи",
        "год выпуска": 2019,
        "актёрский состав": ["Сон Кан Хо", "Ли Сон Кён"],
        "продолжительность": 132
    },
    "Ирландец": {
        "рейтинг": 7.9,
        "описание": "Эпическая история о жизни наемного убийцы",
        "год выпуска": 2019,
        "актёрский состав": ["Роберт Де Ниро", "Аль Пачино"],
        "продолжительность": 209
    },
    "1917": {
        "рейтинг": 8.3,
        "описание": "Драма о миссии спасения во времена Первой мировой войны",
        "год выпуска": 2019,
        "актёрский состав": ["Джордж Маккей", "Дин-Чарльз Чепмен"],
        "продолжительность": 119
    },
    "Паразиты": {
        "рейтинг": 8.6,
        "описание": "Заводная комедия о семье безработных и их хитроумных планах",
        "год выпуска": 2019,
        "актёрский состав": ["Чхве Ву Чжик", "Сон Кан Хо"],
        "продолжительность": 132
    },
    "Достать ножи": {
        "рейтинг": 7.8,
        "описание": "Черная комедия о группе друзей и их странных приключениях",
        "год выпуска": 2019,
        "актёрский состав": ["Дэниэл Крэйг", "Анна де Армас"],
        "продолжительность": 130
    },
    "Джокер": {
        "рейтинг": 8.5,
        "описание": "Темная драма о происхождении злодея из мира комиксов",
        "год выпуска": 2019,
        "актёрский состав": ["Хоакин Феникс", "Роберт Де Ниро"],
        "продолжительность": 122
    },
    "Пианист": {
        "рейтинг": 8.5,
        "описание": "Драма о выживании пианиста во времена Второй мировой войны",
        "год выпуска": 2002,
        "актёрский состав": ["Адриан Броуди", "Томас Кречман"],
        "продолжительность": 150
    },
    "Зеленая книга": {
        "рейтинг": 8.2,
        "описание": "Дружеское путешествие чернокожего музыканта и белого водителя в 1960-е годы",
        "год выпуска": 2018,
        "актёрский состав": ["Махершала Али", "Вигго Мортенсен"],
        "продолжительность": 130
    },
    "Ла-Ла Ленд": {
        "рейтинг": 8.0,
        "описание": "Мюзикл о любви молодых художников в Лос-Анджелесе",
        "год выпуска": 2016,
        "актёрский состав": ["Райан Гослинг", "Эмма Стоун"],
        "продолжительность": 128
    },
    "Темный рыцарь": {
        "рейтинг": 9.0,
        "описание": "Супергеройский боевик о Бэтмене и Джокере",
        "год выпуска": 2008,
        "актёрский состав": ["Кристиан Бэйл", "Хит Леджер"],
        "продолжительность": 152
    }
}
```
отфильтровать его по рейтингу (вывести только те, у которых рейтинг > 8.5)\
вывести только те фильмы, в которых снимался определённый актёр.

---

есть словарь с книгами:
```python
library = {
    "Принцип оборотня": {
        "автор": "Анджелика Варум",
        "год издания": 2007,
        "город издания": "Москва",
        "краткое описание": "Мистический роман о тайнах оборотней и вампиров",
        "жанр": "Фэнтези",
    },
    "Ведьмак": {
        "автор": "Анджей Сапковский",
        "год издания": 1993,
        "город издания": "Варшава",
        "краткое описание": "Приключенческая фэнтези-сага о ведьмаке Геральте",
        "жанр": "Фэнтези",
    },
    "Гарри Поттер и философский камень": {
        "автор": "Джоан Роулинг",
        "год издания": 1997,
        "город издания": "Лондон",
        "краткое описание": "Приключенческая история о юном волшебнике Гарри Поттере",
        "жанр": "Фэнтези",
    },
    "Атлант расправил плечи": {
        "автор": "Айн Рэнд",
        "год издания": 1957,
        "город издания": "Нью-Йорк",
        "краткое описание": "Философский роман о креативных гении и капитализме",
        "жанр": "Философия",
    },
    "Война и мир": {
        "автор": "Лев Толстой",
        "год издания": 1869,
        "город издания": "Москва",
        "краткое описание": "Эпический роман о судьбах русской аристократии во времена Наполеоновских войн",
        "жанр": "Историческая проза",
    },
    "1984": {
        "автор": "Джордж Оруэлл",
        "год издания": 1949,
        "город издания": "Лондон",
        "краткое описание": "Антиутопический роман о тоталитаризме и контроле над людьми",
        "жанр": "Фантастика",
    },
    "Мастер и Маргарита": {
        "автор": "Михаил Булгаков",
        "год издания": 1967,
        "город издания": "Москва",
        "краткое описание": "Философский и аллегорический роман о дьяволе и литературной Москве",
        "жанр": "Магический реализм",
    },
    "Гордость и предубеждение": {
        "автор": "Джейн Остин",
        "год издания": 1813,
        "город издания": "Лондон",
        "краткое описание": "Роман о любви и социальных нормах английского общества начала XIX века",
        "жанр": "Классическая проза",
    },
    "Три товарища": {
        "автор": "Эрих Мария Ремарк",
        "год издания": 1936,
        "город издания": "Цюрих",
        "краткое описание": "Роман о дружбе и любви трех друзей в Германии после Первой мировой войны",
        "жанр": "Роман",
    },
    "Маленький принц": {
        "автор": "Антуан де Сент-Экзюпери",
        "год издания": 1943,
        "город издания": "Нью-Йорк",
        "краткое описание": "Философская сказка о дружбе и жизни на других планетах",
        "жанр": "Философская проза",
    },
    "Гарри Поттер и Кубок огня": {
        "автор": "Джоан Роулинг",
        "год издания": 2000,
        "город издания": "Лондон",
        "краткое описание": "Приключенческая история о Гарри Поттере и Волшебном Кубке",
        "жанр": "Фэнтези",
    },
    "Сумерки": {
        "автор": "Стефани Майер",
        "год издания": 2005,
        "город издания": "Нью-Йорк",
        "краткое описание": "Роман о любви между человеком и вампиром",
        "жанр": "Романтическая фантастика",
    },
    "Тень ветра": {
        "автор": "Карлос Руис Сафон",
        "год издания": 2001,
        "город издания": "Барселона",
        "краткое описание": "Мистический роман о загадочной книге и барселонских тайнах",
        "жанр": "Мистика",
    },
    "Пикник на обочине": {
        "автор": "Аркадий и Борис Стругацкие",
        "год издания": 1972,
        "город издания": "Ленинград",
        "краткое описание": "Научно-фантастический рассказ о пикнике и зоне",
        "жанр": "Научная фантастика",
    },
    "Алиса в Стране чудес": {
        "автор": "Льюис Кэрролл",
        "год издания": 1865,
        "город издания": "Лондон",
        "краткое описание": "Сказка о приключениях девочки Алисы в стране чудес",
        "жанр": "Детская литература",
    }
}
```

найти определённую книгу, поменять какое-нибудь поле в ней(обновить информацию).\

---

есть словарь:
```python
passengers = {
    "Иван Иванов": {
        "возраст": 35,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Италия", "Франция", "Испания"]
    },
    "Анна Петрова": {
        "возраст": 28,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Греция", "Турция"]
    },
    "Джон Смит": {
        "возраст": 42,
        "гражданство": "США",
        "семья": False,
        "последние страны": ["Канада", "Мексика"]
    },
    "Елена Козлова": {
        "возраст": 25,
        "гражданство": "Россия",
        "семья": False,
        "последние страны": ["Таиланд", "Камбоджа"]
    },
    "Мария Гонсалес": {
        "возраст": 30,
        "гражданство": "Испания",
        "семья": True,
        "последние страны": ["Франция", "Португалия"]
    },
    "Алексей Петров": {
        "возраст": 40,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Германия", "Чехия"]
    },
    "Людмила Сидорова": {
        "возраст": 45,
        "гражданство": "Россия",
        "семья": False,
        "последние страны": ["Финляндия"]
    },
    "Давид Ким": {
        "возраст": 32,
        "гражданство": "США",
        "семья": False,
        "последние страны": ["Япония", "Корея"]
    },
    "Ольга Иванова": {
        "возраст": 28,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Турция", "Египет"]
    },
    "Марк Смит": {
        "возраст": 29,
        "гражданство": "США",
        "семья": False,
        "последние страны": ["Канада", "Мексика"]
    },
    "Александра Попова": {
        "возраст": 31,
        "гражданство": "Россия",
        "семья": False,
        "последние страны": ["Италия", "Франция"]
    },
    "Ирина Маркес": {
        "возраст": 27,
        "гражданство": "Испания",
        "семья": True,
        "последние страны": ["Греция", "Турция"]
    },
    "Петр Козлов": {
        "возраст": 38,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Испания", "Португалия"]
    },
    "Наталья Петрова": {
        "возраст": 40,
        "гражданство": "Россия",
        "семья": True,
        "последние страны": ["Франция", "Германия"]
    },
    "Кристина Ли": {
        "возраст": 26,
        "гражданство": "США",
        "семья": False,
        "последние страны": ["Италия", "Испания"]
    }
}
```

отыскать только тех пассажиров, которые были в определённой стране.\
удалить их из словаря, вывести удалённых.
